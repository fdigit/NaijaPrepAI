{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Documents/fDigit%20Technologies/NaijaPrepAI/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["// üí• CRITICAL FIX: Forces Next.js to use the Node.js environment\n// This must be the FIRST line (before any imports) to resolve Prisma initialization errors\nexport const runtime = 'nodejs';\n\nimport type { NextRequest } from 'next/server';\n\n// Dynamic imports to avoid module-level evaluation\n// Import NextAuth and providers only when needed\nlet NextAuthModule: any = null;\nlet CredentialsProviderModule: any = null;\nlet GoogleProviderModule: any = null;\nlet PrismaAdapterModule: any = null;\nlet PrismaModule: any = null;\nlet bcryptModule: any = null;\n\nasync function getNextAuthModule() {\n  if (!NextAuthModule) {\n    NextAuthModule = await import('next-auth');\n  }\n  return NextAuthModule.default;\n}\n\nasync function getCredentialsProvider() {\n  if (!CredentialsProviderModule) {\n    CredentialsProviderModule = await import('next-auth/providers/credentials');\n  }\n  return CredentialsProviderModule.default;\n}\n\nasync function getGoogleProvider() {\n  if (!GoogleProviderModule) {\n    GoogleProviderModule = await import('next-auth/providers/google');\n  }\n  return GoogleProviderModule.default;\n}\n\nasync function getPrisma() {\n  if (!PrismaModule) {\n    PrismaModule = await import('@/lib/prisma');\n  }\n  return PrismaModule.prisma;\n}\n\nasync function getPrismaAdapter() {\n  if (!PrismaAdapterModule) {\n    PrismaAdapterModule = await import('@auth/prisma-adapter');\n  }\n  const prisma = await getPrisma();\n  return PrismaAdapterModule.PrismaAdapter(prisma);\n}\n\nasync function getBcrypt() {\n  if (!bcryptModule) {\n    bcryptModule = await import('bcryptjs');\n  }\n  return bcryptModule.default;\n}\n\n// Validate required environment variables\nfunction validateEnvVars() {\n  const required = ['NEXTAUTH_SECRET', 'DATABASE_URL'];\n  const missing = required.filter(key => !process.env[key]);\n  \n  if (missing.length > 0) {\n    throw new Error(\n      `Missing required environment variables: ${missing.join(', ')}\\n` +\n      `Please create a .env.local file with these variables. See ENV_SETUP_GUIDE.md for details.`\n    );\n  }\n  \n  if (!process.env.NEXTAUTH_SECRET || process.env.NEXTAUTH_SECRET.length < 32) {\n    console.warn(\n      '‚ö†Ô∏è  WARNING: NEXTAUTH_SECRET should be at least 32 characters long for security.'\n    );\n  }\n}\n\n// Make authOptions a getter function to avoid module-level evaluation\nasync function getAuthOptions(): Promise<any> {\n  // Validate environment variables when options are first requested\n  validateEnvVars();\n  \n  const GoogleProvider = await getGoogleProvider();\n  const CredentialsProvider = await getCredentialsProvider();\n  \n  // Note: Adapter removed temporarily to fix __internal error\n  // JWT strategy works without adapter - adapter is only needed for database sessions\n  // We can add it back later once NextAuth v5 beta compatibility is resolved\n  \n  return {\n    // adapter: await getPrismaAdapter(), // Temporarily disabled\n    secret: process.env.NEXTAUTH_SECRET!,\n    trustHost: true,\n    basePath: '/api/auth',\n    providers: [\n      GoogleProvider({\n        clientId: process.env.GOOGLE_CLIENT_ID || '',\n        clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',\n      }),\n      CredentialsProvider({\n        name: 'Credentials',\n        credentials: {\n          email: { label: 'Email', type: 'email' },\n          password: { label: 'Password', type: 'password' },\n        },\n        async authorize(credentials: any) {\n          if (!credentials?.email || !credentials?.password) {\n            return null;\n          }\n\n          // Normalize email: trim and lowercase to match database storage\n          const email = credentials.email.toString().trim().toLowerCase();\n          const password = credentials.password as string;\n\n          try {\n            // Import prisma directly - singleton pattern handles hot-reload\n            const { prisma } = await import('@/lib/prisma');\n            const user = await prisma.user.findUnique({\n              where: { email },\n            });\n\n            if (!user || !user.password) {\n              return null;\n            }\n\n            // Verify password\n            const bcrypt = await getBcrypt();\n            const isPasswordValid = await bcrypt.compare(password, user.password);\n\n            if (!isPasswordValid) {\n              return null;\n            }\n\n            return {\n              id: user.id,\n              email: user.email,\n              name: user.name,\n              image: user.image,\n            };\n          } catch (error) {\n            console.error('Auth error:', error);\n            return null;\n          }\n        },\n      }),\n    ],\n    session: {\n      strategy: 'jwt',\n    },\n    pages: {\n      signIn: '/auth/signin',\n    },\n    callbacks: {\n      async jwt({ token, user }: { token: any; user: any }) {\n        if (user) {\n          token.id = user.id;\n          token.email = user.email;\n          token.name = user.name;\n          token.picture = user.image;\n        }\n        return token;\n      },\n      async session({ session, token }: { session: any; token: any }) {\n        // Debug logging\n        console.log('Session callback - token:', { id: token.id, email: token.email, name: token.name });\n        console.log('Session callback - session before:', { hasUser: !!session.user, userKeys: session.user ? Object.keys(session.user) : [] });\n        \n        // Always ensure user object exists\n        if (!session.user) {\n          session.user = {};\n        }\n        \n        // Populate user object from token\n        if (token.id) {\n          session.user.id = token.id as string;\n        }\n        if (token.email) {\n          session.user.email = token.email;\n        }\n        if (token.name) {\n          session.user.name = token.name;\n        }\n        if (token.picture || token.image) {\n          session.user.image = token.picture || token.image;\n        }\n        \n        console.log('Session callback - session after:', { hasUser: !!session.user, userId: session.user.id, userKeys: Object.keys(session.user) });\n        return session;\n      },\n    },\n  };\n}\n\n// Note: authOptions is NOT exported to prevent module-level evaluation\n// All files should use the auth() function instead\n// If you absolutely need authOptions, use getAuthOptions() (internal only)\n\n// Initialize NextAuth - using lazy initialization to avoid module evaluation issues\nlet nextAuthInstance: any = null;\n\nasync function getNextAuth() {\n  if (!nextAuthInstance) {\n    try {\n      const NextAuth = await getNextAuthModule();\n      const authOptions = await getAuthOptions();\n      nextAuthInstance = NextAuth(authOptions);\n    } catch (error: any) {\n      console.error('‚ùå Failed to initialize NextAuth:', error);\n      if (error.message?.includes('environment variables')) {\n        console.error('\\nüìã Please check ENV_SETUP_GUIDE.md for setup instructions.');\n      }\n      throw error;\n    }\n  }\n  return nextAuthInstance;\n}\n\n// Export handlers with explicit parameter handling and error handling\nexport async function GET(\n  req: Request,\n  context: { params: Promise<{ nextauth?: string[] }> }\n) {\n  try {\n    const { handlers } = await getNextAuth();\n    return handlers.GET(req as any);\n  } catch (error: any) {\n    console.error('‚ùå Auth GET handler error:', error);\n    // Return a proper JSON error response instead of HTML\n    return new Response(\n      JSON.stringify({ \n        error: 'Authentication configuration error',\n        message: error.message || 'Please check your environment variables. See ENV_SETUP_GUIDE.md'\n      }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      }\n    );\n  }\n}\n\nexport async function POST(\n  req: Request,\n  context: { params: Promise<{ nextauth?: string[] }> }\n) {\n  try {\n    const { handlers } = await getNextAuth();\n    return handlers.POST(req as any);\n  } catch (error: any) {\n    console.error('‚ùå Auth POST handler error:', error);\n    // Return a proper JSON error response instead of HTML\n    return new Response(\n      JSON.stringify({ \n        error: 'Authentication configuration error',\n        message: error.message || 'Please check your environment variables. See ENV_SETUP_GUIDE.md'\n      }),\n      {\n        status: 500,\n        headers: { 'Content-Type': 'application/json' },\n      }\n    );\n  }\n}\n\n// Export auth utilities - all lazy to avoid module-level initialization\nexport async function auth(req?: Request | NextRequest | any) {\n  const nextAuth = await getNextAuth();\n  try {\n    if (req) {\n      // For NextRequest, we need to construct a proper Request with cookies\n      let request: Request;\n      \n      if (req instanceof Request) {\n        // It's already a Request\n        request = req;\n      } else {\n        // It's a NextRequest - get URL and headers properly\n        let url: string;\n        let headers: Headers;\n        \n        // For NextRequest, use url property directly (it's always available)\n        url = (req as any).url || (req as any).href || 'http://localhost:3000';\n        \n        // CRITICAL: Copy all headers including cookies from NextRequest\n        // NextRequest.headers is a Headers object, we need to copy it properly\n        if ((req as any).headers) {\n          headers = new Headers();\n          // Copy all headers from NextRequest to new Headers object\n          (req as any).headers.forEach((value: string, key: string) => {\n            headers.set(key, value);\n          });\n        } else {\n          headers = new Headers();\n        }\n        \n        request = new Request(url, {\n          method: (req as any).method || 'GET',\n          headers: headers,\n        });\n      }\n      \n      const result = await nextAuth.auth(request as any);\n      console.log('auth() result with request:', {\n        hasResult: !!result,\n        hasUser: !!result?.user,\n        userId: result?.user?.id,\n        resultKeys: result ? Object.keys(result) : [],\n        resultType: typeof result,\n        resultStringified: JSON.stringify(result),\n      });\n      \n      // NextAuth v5 beta might return { session } instead of session directly\n      if (result && typeof result === 'object' && 'session' in result) {\n        console.log('Found session in result.session:', result.session);\n        return result.session;\n      }\n      \n      return result;\n    }\n    // In API routes, auth() should automatically read from headers\n    const result = await nextAuth.auth();\n    console.log('auth() result without request:', {\n      hasResult: !!result,\n      hasUser: !!result?.user,\n      userId: result?.user?.id,\n      resultKeys: result ? Object.keys(result) : [],\n      resultType: typeof result,\n      resultStringified: JSON.stringify(result),\n    });\n    \n    // NextAuth v5 beta might return { session } instead of session directly\n    if (result && typeof result === 'object' && 'session' in result) {\n      console.log('Found session in result.session:', result.session);\n      return result.session;\n    }\n    \n    return result;\n  } catch (error: any) {\n    console.error('Error in auth() function:', error);\n    console.error('Error details:', {\n      message: error.message,\n      stack: error.stack?.split('\\n').slice(0, 5).join('\\n'),\n      reqType: req ? typeof req : 'undefined',\n      hasNextUrl: req && typeof req === 'object' ? 'nextUrl' in req : false,\n      nextUrlValue: req && typeof req === 'object' && 'nextUrl' in req ? (req as any).nextUrl : 'N/A',\n    });\n    return null;\n  }\n}\n\nexport async function signIn(...args: any[]) {\n  const nextAuth = await getNextAuth();\n  return nextAuth.signIn(...args as any);\n}\n\nexport async function signOut(...args: any[]) {\n  const nextAuth = await getNextAuth();\n  return nextAuth.signOut(...args as any);\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 394, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Documents/fDigit%20Technologies/NaijaPrepAI/lib/prisma.ts"],"sourcesContent":["// lib/prisma.ts\n\nimport { PrismaClient } from '@prisma/client';\n\n// Extend the Global interface for TypeScript to recognize the global prisma property\ndeclare global {\n  // eslint-disable-next-line no-var\n  var cachedPrisma: PrismaClient;\n}\n\n// Lazy initialization function - only creates PrismaClient when called\n// This prevents module-level evaluation issues with Next.js 16 + Turbopack\nfunction getPrismaClient(): PrismaClient {\n  if (process.env.NODE_ENV === 'production') {\n    // In production, always create a new client\n    return new PrismaClient();\n  } else {\n    // In development, use the global object to keep a single instance\n    if (!global.cachedPrisma) {\n      // Create PrismaClient only when function is called (not at module load)\n      global.cachedPrisma = new PrismaClient();\n    }\n    return global.cachedPrisma;\n  }\n}\n\n// Export as a Proxy to make it truly lazy - only creates client when property is accessed\nexport const prisma = new Proxy({} as PrismaClient, {\n  get(_target, prop) {\n    const client = getPrismaClient();\n    const value = client[prop as keyof PrismaClient];\n    // If it's a function, bind it to the client instance\n    if (typeof value === 'function') {\n      return value.bind(client);\n    }\n    return value;\n  },\n});\n\nexport default prisma;\n"],"names":[],"mappings":"AAAA,gBAAgB;;;;;;;AAEhB;;AAQA,uEAAuE;AACvE,2EAA2E;AAC3E,SAAS;IACP;;SAGO;QACL,kEAAkE;QAClE,IAAI,CAAC,OAAO,YAAY,EAAE;YACxB,wEAAwE;YACxE,OAAO,YAAY,GAAG,IAAI,6IAAY;QACxC;QACA,OAAO,OAAO,YAAY;IAC5B;AACF;AAGO,MAAM,SAAS,IAAI,MAAM,CAAC,GAAmB;IAClD,KAAI,OAAO,EAAE,IAAI;QACf,MAAM,SAAS;QACf,MAAM,QAAQ,MAAM,CAAC,KAA2B;QAChD,qDAAqD;QACrD,IAAI,OAAO,UAAU,YAAY;YAC/B,OAAO,MAAM,IAAI,CAAC;QACpB;QACA,OAAO;IACT;AACF;uCAEe"}},
    {"offset": {"line": 433, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Documents/fDigit%20Technologies/NaijaPrepAI/services/quizService.ts"],"sourcesContent":["import { prisma } from '../lib/prisma';\r\n\r\nexport interface QuizAttemptData {\r\n  userId: string;\r\n  lessonId: string;\r\n  totalQuestions: number;\r\n  correctAnswers: number;\r\n  score: number; // Percentage (0-100)\r\n  timeSpent?: number; // Seconds\r\n  answers: Array<{\r\n    questionIndex: number;\r\n    selectedOption: number;\r\n    isCorrect: boolean;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Save a quiz attempt to the database\r\n */\r\nexport const saveQuizAttempt = async (data: QuizAttemptData) => {\r\n  try {\r\n    const attempt = await prisma.quizAttempt.create({\r\n      data: {\r\n        userId: data.userId,\r\n        lessonId: data.lessonId,\r\n        totalQuestions: data.totalQuestions,\r\n        correctAnswers: data.correctAnswers,\r\n        score: data.score,\r\n        timeSpent: data.timeSpent,\r\n        answers: data.answers as any, // Store as JSON\r\n      },\r\n    });\r\n    return attempt;\r\n  } catch (error) {\r\n    console.error('Error saving quiz attempt:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get quiz attempts for a user\r\n */\r\nexport const getUserQuizAttempts = async (userId: string) => {\r\n  try {\r\n    const attempts = await prisma.quizAttempt.findMany({\r\n      where: { userId },\r\n      include: {\r\n        lesson: {\r\n          select: {\r\n            id: true,\r\n            subject: true,\r\n            topicTitle: true,\r\n            classLevel: true,\r\n            term: true,\r\n            week: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        createdAt: 'desc',\r\n      },\r\n    });\r\n    return attempts;\r\n  } catch (error) {\r\n    console.error('Error fetching quiz attempts:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get quiz attempts grouped by subject\r\n */\r\nexport const getQuizAttemptsBySubject = async (userId: string) => {\r\n  try {\r\n    const attempts = await prisma.quizAttempt.findMany({\r\n      where: { userId },\r\n      include: {\r\n        lesson: {\r\n          select: {\r\n            subject: true,\r\n          },\r\n        },\r\n      },\r\n    });\r\n\r\n    // If no attempts, return empty object\r\n    if (attempts.length === 0) {\r\n      return {};\r\n    }\r\n\r\n    // Group by subject\r\n    const subjectStats: Record<\r\n      string,\r\n      {\r\n        totalAttempts: number;\r\n        totalQuestions: number;\r\n        totalCorrect: number;\r\n        averageScore: number;\r\n        bestScore: number;\r\n        worstScore: number;\r\n        attempts: Array<{\r\n          id: string;\r\n          score: number;\r\n          correctAnswers: number;\r\n          totalQuestions: number;\r\n          createdAt: Date;\r\n          lessonTitle?: string;\r\n        }>;\r\n      }\r\n    > = {};\r\n\r\n    attempts.forEach((attempt) => {\r\n      // Skip if lesson is null (shouldn't happen, but safety check)\r\n      if (!attempt.lesson) {\r\n        console.warn('Quiz attempt has no lesson:', attempt.id);\r\n        return;\r\n      }\r\n\r\n      const subject = attempt.lesson.subject || 'Unknown';\r\n      if (!subjectStats[subject]) {\r\n        subjectStats[subject] = {\r\n          totalAttempts: 0,\r\n          totalQuestions: 0,\r\n          totalCorrect: 0,\r\n          averageScore: 0,\r\n          bestScore: 0,\r\n          worstScore: 100,\r\n          attempts: [],\r\n        };\r\n      }\r\n\r\n      const stats = subjectStats[subject];\r\n      stats.totalAttempts += 1;\r\n      stats.totalQuestions += attempt.totalQuestions;\r\n      stats.totalCorrect += attempt.correctAnswers;\r\n      stats.bestScore = Math.max(stats.bestScore, attempt.score);\r\n      // Initialize worstScore on first attempt, then compare\r\n      if (stats.totalAttempts === 1) {\r\n        stats.worstScore = attempt.score;\r\n      } else {\r\n        stats.worstScore = Math.min(stats.worstScore, attempt.score);\r\n      }\r\n\r\n      stats.attempts.push({\r\n        id: attempt.id,\r\n        score: attempt.score,\r\n        correctAnswers: attempt.correctAnswers,\r\n        totalQuestions: attempt.totalQuestions,\r\n        createdAt: attempt.createdAt,\r\n      });\r\n    });\r\n\r\n    // Calculate averages\r\n    Object.keys(subjectStats).forEach((subject) => {\r\n      const stats = subjectStats[subject];\r\n      stats.averageScore =\r\n        stats.totalAttempts > 0 && stats.totalQuestions > 0\r\n          ? Math.round((stats.totalCorrect / stats.totalQuestions) * 100 * 100) / 100\r\n          : 0;\r\n    });\r\n\r\n    return subjectStats;\r\n  } catch (error) {\r\n    console.error('Error fetching quiz attempts by subject:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Get recent quiz attempts for a specific subject\r\n */\r\nexport const getRecentQuizAttemptsBySubject = async (\r\n  userId: string,\r\n  subject: string,\r\n  limit: number = 10\r\n) => {\r\n  try {\r\n    const attempts = await prisma.quizAttempt.findMany({\r\n      where: {\r\n        userId,\r\n        lesson: {\r\n          subject,\r\n        },\r\n      },\r\n      include: {\r\n        lesson: {\r\n          select: {\r\n            topicTitle: true,\r\n            subject: true,\r\n            classLevel: true,\r\n            term: true,\r\n            week: true,\r\n          },\r\n        },\r\n      },\r\n      orderBy: {\r\n        createdAt: 'desc',\r\n      },\r\n      take: limit,\r\n    });\r\n    return attempts;\r\n  } catch (error) {\r\n    console.error('Error fetching recent quiz attempts by subject:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 595, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Documents/fDigit%20Technologies/NaijaPrepAI/services/gamificationService.ts"],"sourcesContent":["import { prisma } from '../lib/prisma';\r\n\r\n/**\r\n * Gamification Service\r\n * Handles XP points, badges, streaks, and achievements\r\n */\r\n\r\n// XP Point Values\r\nexport const XP_VALUES = {\r\n  GENERATE_LESSON: 50,\r\n  COMPLETE_QUIZ: 30,\r\n  QUIZ_PERFECT_SCORE: 50, // Bonus for 100% quiz score\r\n  COMPLETE_EXAM_PREP: 100,\r\n  EXAM_PREP_HIGH_SCORE: 150, // Bonus for 80%+ exam score\r\n  DAILY_STREAK_BONUS: 10, // Bonus XP per day of streak\r\n} as const;\r\n\r\n// Badge Definitions\r\nexport const BADGES = {\r\n  // Learning Badges\r\n  FIRST_LESSON: { id: 'first_lesson', name: 'First Steps', description: 'Generated your first lesson', icon: 'üéØ' },\r\n  FAST_LEARNER: { id: 'fast_learner', name: 'Fast Learner', description: 'Completed 5 quizzes in one day', icon: '‚ö°' },\r\n  CONSISTENT_STUDENT: { id: 'consistent_student', name: 'Consistent Student', description: '7-day study streak', icon: 'üî•' },\r\n  DEDICATED_LEARNER: { id: 'dedicated_learner', name: 'Dedicated Learner', description: '30-day study streak', icon: 'üí™' },\r\n  \r\n  // Subject Mastery Badges\r\n  MATH_GURU: { id: 'math_guru', name: 'Mathematics Guru', description: 'Completed 10 Mathematics lessons', icon: 'üìê' },\r\n  SCIENCE_MASTER: { id: 'science_master', name: 'Science Master', description: 'Completed 10 Science lessons', icon: 'üî¨' },\r\n  ENGLISH_EXPERT: { id: 'english_expert', name: 'English Expert', description: 'Completed 10 English lessons', icon: 'üìö' },\r\n  \r\n  // Achievement Badges\r\n  QUIZ_MASTER: { id: 'quiz_master', name: 'Quiz Master', description: 'Scored 100% on 5 quizzes', icon: 'üèÜ' },\r\n  EXAM_CHAMPION: { id: 'exam_champion', name: 'Exam Champion', description: 'Scored 90%+ on an exam prep', icon: 'üëë' },\r\n  LESSON_CREATOR: { id: 'lesson_creator', name: 'Lesson Creator', description: 'Generated 20 lessons', icon: '‚ú®' },\r\n  XP_LEGEND: { id: 'xp_legend', name: 'XP Legend', description: 'Reached 10,000 XP points', icon: 'üåü' },\r\n} as const;\r\n\r\n// Level thresholds (XP required for each level)\r\nconst LEVEL_THRESHOLDS = [\r\n  0,      // Level 1\r\n  100,    // Level 2\r\n  250,    // Level 3\r\n  500,    // Level 4\r\n  1000,   // Level 5\r\n  2000,   // Level 6\r\n  3500,   // Level 7\r\n  5500,   // Level 8\r\n  8000,   // Level 9\r\n  10000,  // Level 10\r\n  15000,  // Level 11\r\n  20000,  // Level 12\r\n  30000,  // Level 13\r\n  40000,  // Level 14\r\n  50000,  // Level 15\r\n];\r\n\r\n/**\r\n * Calculate user level based on XP\r\n */\r\nexport function calculateLevel(xp: number): number {\r\n  for (let i = LEVEL_THRESHOLDS.length - 1; i >= 0; i--) {\r\n    if (xp >= LEVEL_THRESHOLDS[i]) {\r\n      return i + 1;\r\n    }\r\n  }\r\n  return 1;\r\n}\r\n\r\n/**\r\n * Calculate XP needed for next level\r\n */\r\nexport function getXPForNextLevel(currentXP: number): number {\r\n  const currentLevel = calculateLevel(currentXP);\r\n  if (currentLevel >= LEVEL_THRESHOLDS.length) {\r\n    return 0; // Max level\r\n  }\r\n  return LEVEL_THRESHOLDS[currentLevel] - currentXP;\r\n}\r\n\r\n/**\r\n * Award XP to user\r\n */\r\nexport async function awardXP(\r\n  userId: string,\r\n  xpAmount: number,\r\n  reason: string\r\n): Promise<{ newXP: number; newLevel: number; leveledUp: boolean }> {\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: { xpPoints: true, level: true },\r\n  });\r\n\r\n  if (!user) {\r\n    throw new Error('User not found');\r\n  }\r\n\r\n  const newXP = user.xpPoints + xpAmount;\r\n  const oldLevel = user.level;\r\n  const newLevel = calculateLevel(newXP);\r\n  const leveledUp = newLevel > oldLevel;\r\n\r\n  await prisma.user.update({\r\n    where: { id: userId },\r\n    data: {\r\n      xpPoints: newXP,\r\n      level: newLevel,\r\n    },\r\n  });\r\n\r\n  // Check for level-based badges\r\n  if (leveledUp) {\r\n    await checkAndAwardBadges(userId, { level: newLevel });\r\n  }\r\n\r\n  return { newXP, newLevel, leveledUp };\r\n}\r\n\r\n/**\r\n * Update daily streak\r\n */\r\nexport async function updateDailyStreak(userId: string): Promise<{ streak: number; isNewStreak: boolean }> {\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: { dailyStreak: true, lastActivityDate: true },\r\n  });\r\n\r\n  if (!user) {\r\n    throw new Error('User not found');\r\n  }\r\n\r\n  const today = new Date();\r\n  today.setHours(0, 0, 0, 0);\r\n\r\n  const lastActivity = user.lastActivityDate\r\n    ? new Date(user.lastActivityDate)\r\n    : null;\r\n  if (lastActivity) {\r\n    lastActivity.setHours(0, 0, 0, 0);\r\n  }\r\n\r\n  let newStreak = user.dailyStreak;\r\n  let isNewStreak = false;\r\n\r\n  if (!lastActivity) {\r\n    // First activity\r\n    newStreak = 1;\r\n    isNewStreak = true;\r\n  } else {\r\n    const daysDiff = Math.floor((today.getTime() - lastActivity.getTime()) / (1000 * 60 * 60 * 24));\r\n\r\n    if (daysDiff === 0) {\r\n      // Same day, no change\r\n      newStreak = user.dailyStreak;\r\n    } else if (daysDiff === 1) {\r\n      // Consecutive day\r\n      newStreak = user.dailyStreak + 1;\r\n      isNewStreak = true;\r\n    } else {\r\n      // Streak broken\r\n      newStreak = 1;\r\n      isNewStreak = true;\r\n    }\r\n  }\r\n\r\n  // Award streak bonus XP\r\n  if (isNewStreak && newStreak > 1) {\r\n    const streakBonus = (newStreak - 1) * XP_VALUES.DAILY_STREAK_BONUS;\r\n    await awardXP(userId, streakBonus, `Daily streak bonus (${newStreak} days)`);\r\n  }\r\n\r\n  await prisma.user.update({\r\n    where: { id: userId },\r\n    data: {\r\n      dailyStreak: newStreak,\r\n      lastActivityDate: today,\r\n    },\r\n  });\r\n\r\n  // Check for streak-based badges\r\n  await checkAndAwardBadges(userId, { streak: newStreak });\r\n\r\n  return { streak: newStreak, isNewStreak };\r\n}\r\n\r\n/**\r\n * Award a badge to user\r\n */\r\nexport async function awardBadge(\r\n  userId: string,\r\n  badgeId: string\r\n): Promise<boolean> {\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: { badges: true },\r\n  });\r\n\r\n  if (!user) {\r\n    throw new Error('User not found');\r\n  }\r\n\r\n  // Check if badge already awarded\r\n  if (user.badges.includes(badgeId)) {\r\n    return false;\r\n  }\r\n\r\n  const updatedBadges = [...user.badges, badgeId];\r\n  await prisma.user.update({\r\n    where: { id: userId },\r\n    data: {\r\n      badges: updatedBadges,\r\n    },\r\n  });\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Check and award badges based on achievements\r\n */\r\nexport async function checkAndAwardBadges(\r\n  userId: string,\r\n  context: {\r\n    level?: number;\r\n    streak?: number;\r\n    lessonsGenerated?: number;\r\n    quizzesCompleted?: number;\r\n    perfectQuizzes?: number;\r\n    subject?: string;\r\n    subjectLessons?: number;\r\n    examScore?: number;\r\n    totalXP?: number;\r\n  }\r\n): Promise<string[]> {\r\n  const awardedBadges: string[] = [];\r\n\r\n  // Get current user stats\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: {\r\n      badges: true,\r\n      xpPoints: true,\r\n      lessons: { select: { id: true, subject: true } },\r\n      quizAttempts: {\r\n        select: { id: true, score: true },\r\n      },\r\n      examPrepAttempts: {\r\n        select: { id: true, score: true },\r\n      },\r\n    },\r\n  });\r\n\r\n  if (!user) {\r\n    return awardedBadges;\r\n  }\r\n\r\n  // Level-based badges\r\n  if (context.level && context.level >= 10) {\r\n    if (!user.badges.includes(BADGES.XP_LEGEND.id)) {\r\n      await awardBadge(userId, BADGES.XP_LEGEND.id);\r\n      awardedBadges.push(BADGES.XP_LEGEND.id);\r\n    }\r\n  }\r\n\r\n  // Streak-based badges\r\n  if (context.streak) {\r\n    if (context.streak >= 7 && !user.badges.includes(BADGES.CONSISTENT_STUDENT.id)) {\r\n      await awardBadge(userId, BADGES.CONSISTENT_STUDENT.id);\r\n      awardedBadges.push(BADGES.CONSISTENT_STUDENT.id);\r\n    }\r\n    if (context.streak >= 30 && !user.badges.includes(BADGES.DEDICATED_LEARNER.id)) {\r\n      await awardBadge(userId, BADGES.DEDICATED_LEARNER.id);\r\n      awardedBadges.push(BADGES.DEDICATED_LEARNER.id);\r\n    }\r\n  }\r\n\r\n  // Lesson-based badges\r\n  const lessonsCount = user.lessons.length;\r\n  if (lessonsCount >= 1 && !user.badges.includes(BADGES.FIRST_LESSON.id)) {\r\n    await awardBadge(userId, BADGES.FIRST_LESSON.id);\r\n    awardedBadges.push(BADGES.FIRST_LESSON.id);\r\n  }\r\n  if (lessonsCount >= 20 && !user.badges.includes(BADGES.LESSON_CREATOR.id)) {\r\n    await awardBadge(userId, BADGES.LESSON_CREATOR.id);\r\n    awardedBadges.push(BADGES.LESSON_CREATOR.id);\r\n  }\r\n\r\n  // Quiz-based badges\r\n  const perfectQuizzes = user.quizAttempts.filter((q) => q.score === 100).length;\r\n  if (perfectQuizzes >= 5 && !user.badges.includes(BADGES.QUIZ_MASTER.id)) {\r\n    await awardBadge(userId, BADGES.QUIZ_MASTER.id);\r\n    awardedBadges.push(BADGES.QUIZ_MASTER.id);\r\n  }\r\n\r\n  // Subject-based badges\r\n  if (context.subject) {\r\n    const subjectLessons = user.lessons.filter((l) => l.subject === context.subject).length;\r\n    if (context.subject === 'Mathematics' && subjectLessons >= 10 && !user.badges.includes(BADGES.MATH_GURU.id)) {\r\n      await awardBadge(userId, BADGES.MATH_GURU.id);\r\n      awardedBadges.push(BADGES.MATH_GURU.id);\r\n    }\r\n    if (['Physics', 'Chemistry', 'Biology'].includes(context.subject) && subjectLessons >= 10 && !user.badges.includes(BADGES.SCIENCE_MASTER.id)) {\r\n      await awardBadge(userId, BADGES.SCIENCE_MASTER.id);\r\n      awardedBadges.push(BADGES.SCIENCE_MASTER.id);\r\n    }\r\n    if (context.subject === 'English' && subjectLessons >= 10 && !user.badges.includes(BADGES.ENGLISH_EXPERT.id)) {\r\n      await awardBadge(userId, BADGES.ENGLISH_EXPERT.id);\r\n      awardedBadges.push(BADGES.ENGLISH_EXPERT.id);\r\n    }\r\n  }\r\n\r\n  // Exam-based badges\r\n  if (context.examScore && context.examScore >= 90) {\r\n    if (!user.badges.includes(BADGES.EXAM_CHAMPION.id)) {\r\n      await awardBadge(userId, BADGES.EXAM_CHAMPION.id);\r\n      awardedBadges.push(BADGES.EXAM_CHAMPION.id);\r\n    }\r\n  }\r\n\r\n  return awardedBadges;\r\n}\r\n\r\n/**\r\n * Update subject progress\r\n */\r\nexport async function updateSubjectProgress(\r\n  userId: string,\r\n  subject: string,\r\n  update: {\r\n    lessonsCompleted?: number;\r\n    quizzesPassed?: number;\r\n    xpEarned?: number;\r\n  }\r\n): Promise<void> {\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: { subjectProgress: true },\r\n  });\r\n\r\n  if (!user) {\r\n    throw new Error('User not found');\r\n  }\r\n\r\n  const progress = (user.subjectProgress as Record<string, any>) || {};\r\n  const subjectData = progress[subject] || {\r\n    lessonsCompleted: 0,\r\n    quizzesPassed: 0,\r\n    xpEarned: 0,\r\n  };\r\n\r\n  if (update.lessonsCompleted !== undefined) {\r\n    subjectData.lessonsCompleted = (subjectData.lessonsCompleted || 0) + update.lessonsCompleted;\r\n  }\r\n  if (update.quizzesPassed !== undefined) {\r\n    subjectData.quizzesPassed = (subjectData.quizzesPassed || 0) + update.quizzesPassed;\r\n  }\r\n  if (update.xpEarned !== undefined) {\r\n    subjectData.xpEarned = (subjectData.xpEarned || 0) + update.xpEarned;\r\n  }\r\n\r\n  progress[subject] = subjectData;\r\n\r\n  await prisma.user.update({\r\n    where: { id: userId },\r\n    data: {\r\n      subjectProgress: progress as any,\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * Get user gamification stats\r\n */\r\nexport async function getUserGamificationStats(userId: string) {\r\n  const user = await prisma.user.findUnique({\r\n    where: { id: userId },\r\n    select: {\r\n      xpPoints: true,\r\n      level: true,\r\n      badges: true,\r\n      dailyStreak: true,\r\n      lastActivityDate: true,\r\n      subjectProgress: true,\r\n      lessons: {\r\n        select: { id: true, subject: true },\r\n      },\r\n      quizAttempts: {\r\n        select: { id: true, score: true, createdAt: true },\r\n      },\r\n    },\r\n  });\r\n\r\n  if (!user) {\r\n    throw new Error('User not found');\r\n  }\r\n\r\n  const xpForNextLevel = getXPForNextLevel(user.xpPoints);\r\n  const progressToNextLevel = user.level < LEVEL_THRESHOLDS.length\r\n    ? ((user.xpPoints - LEVEL_THRESHOLDS[user.level - 1]) / (LEVEL_THRESHOLDS[user.level] - LEVEL_THRESHOLDS[user.level - 1])) * 100\r\n    : 100;\r\n\r\n  // Get badge details\r\n  const badgeDetails = user.badges.map((badgeId) => {\r\n    const badge = Object.values(BADGES).find((b) => b.id === badgeId);\r\n    return badge || null;\r\n  }).filter(Boolean);\r\n\r\n  return {\r\n    xp: user.xpPoints,\r\n    level: user.level,\r\n    xpForNextLevel,\r\n    progressToNextLevel,\r\n    badges: badgeDetails,\r\n    dailyStreak: user.dailyStreak,\r\n    lastActivityDate: user.lastActivityDate,\r\n    subjectProgress: user.subjectProgress || {},\r\n    totalLessons: user.lessons.length,\r\n    totalQuizzes: user.quizAttempts.length,\r\n    perfectQuizzes: user.quizAttempts.filter((q) => q.score === 100).length,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1050, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Documents/fDigit%20Technologies/NaijaPrepAI/services/studySessionService.ts"],"sourcesContent":["import { prisma } from '../lib/prisma';\r\n\r\n/**\r\n * Study Session Service\r\n * Tracks user study activities for weekly progress\r\n */\r\n\r\n/**\r\n * Create or update a study session for today\r\n * This ensures we track daily activity for weekly progress\r\n */\r\nexport async function recordStudySession(\r\n  userId: string,\r\n  options?: {\r\n    lessonId?: string;\r\n    duration?: number; // Minutes\r\n  }\r\n): Promise<void> {\r\n  try {\r\n    const today = new Date();\r\n    today.setHours(0, 0, 0, 0);\r\n\r\n    // Check if a session already exists for today\r\n    const existingSession = await prisma.studySession.findFirst({\r\n      where: {\r\n        userId,\r\n        date: {\r\n          gte: today,\r\n          lt: new Date(today.getTime() + 24 * 60 * 60 * 1000), // Next day\r\n        },\r\n      },\r\n    });\r\n\r\n    if (existingSession) {\r\n      // Update existing session - add duration if provided\r\n      if (options?.duration) {\r\n        await prisma.studySession.update({\r\n          where: { id: existingSession.id },\r\n          data: {\r\n            duration: existingSession.duration + options.duration,\r\n            ...(options.lessonId && { lessonId: options.lessonId }),\r\n          },\r\n        });\r\n      }\r\n    } else {\r\n      // Create new session for today\r\n      await prisma.studySession.create({\r\n        data: {\r\n          userId,\r\n          date: today,\r\n          duration: options?.duration || 5, // Default 5 minutes for any activity\r\n          ...(options?.lessonId && { lessonId: options.lessonId }),\r\n        },\r\n      });\r\n    }\r\n  } catch (error) {\r\n    // Don't fail the main operation if study session tracking fails\r\n    console.error('Error recording study session:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Record study session when user generates a lesson\r\n */\r\nexport async function recordLessonGeneration(userId: string, lessonId: string): Promise<void> {\r\n  await recordStudySession(userId, {\r\n    lessonId,\r\n    duration: 10, // Generating a lesson counts as ~10 minutes of study\r\n  });\r\n}\r\n\r\n/**\r\n * Record study session when user completes a quiz\r\n */\r\nexport async function recordQuizCompletion(\r\n  userId: string,\r\n  lessonId: string,\r\n  timeSpent?: number\r\n): Promise<void> {\r\n  // Convert seconds to minutes, or default to 5 minutes\r\n  const duration = timeSpent ? Math.max(1, Math.round(timeSpent / 60)) : 5;\r\n  \r\n  await recordStudySession(userId, {\r\n    lessonId,\r\n    duration,\r\n  });\r\n}\r\n\r\n/**\r\n * Record study session when user completes an exam prep\r\n */\r\nexport async function recordExamPrepCompletion(\r\n  userId: string,\r\n  timeSpent?: number\r\n): Promise<void> {\r\n  // Convert seconds to minutes, or default to 15 minutes for exam prep\r\n  const duration = timeSpent ? Math.max(1, Math.round(timeSpent / 60)) : 15;\r\n  \r\n  await recordStudySession(userId, {\r\n    duration,\r\n  });\r\n}\r\n\r\n/**\r\n * Get weekly study statistics\r\n */\r\nexport async function getWeeklyStats(userId: string) {\r\n  const today = new Date();\r\n  const startOfWeek = new Date(today);\r\n  startOfWeek.setDate(today.getDate() - today.getDay() + 1); // Monday\r\n  startOfWeek.setHours(0, 0, 0, 0);\r\n\r\n  const endOfWeek = new Date(startOfWeek);\r\n  endOfWeek.setDate(startOfWeek.getDate() + 6);\r\n  endOfWeek.setHours(23, 59, 59, 999);\r\n\r\n  const sessions = await prisma.studySession.findMany({\r\n    where: {\r\n      userId,\r\n      date: {\r\n        gte: startOfWeek,\r\n        lte: endOfWeek,\r\n      },\r\n    },\r\n    include: {\r\n      lesson: {\r\n        select: {\r\n          subject: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n\r\n  const totalMinutes = sessions.reduce((sum, session) => sum + session.duration, 0);\r\n  const uniqueDays = new Set(\r\n    sessions.map((s) => {\r\n      const d = new Date(s.date);\r\n      d.setHours(0, 0, 0, 0);\r\n      return d.getTime();\r\n    })\r\n  ).size;\r\n\r\n  return {\r\n    totalSessions: sessions.length,\r\n    totalMinutes,\r\n    totalHours: Math.round((totalMinutes / 60) * 10) / 10,\r\n    daysActive: uniqueDays,\r\n    sessions,\r\n  };\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAWO,eAAe,mBACpB,MAAc,EACd,OAGC;IAED,IAAI;QACF,MAAM,QAAQ,IAAI;QAClB,MAAM,QAAQ,CAAC,GAAG,GAAG,GAAG;QAExB,8CAA8C;QAC9C,MAAM,kBAAkB,MAAM,yHAAM,CAAC,YAAY,CAAC,SAAS,CAAC;YAC1D,OAAO;gBACL;gBACA,MAAM;oBACJ,KAAK;oBACL,IAAI,IAAI,KAAK,MAAM,OAAO,KAAK,KAAK,KAAK,KAAK;gBAChD;YACF;QACF;QAEA,IAAI,iBAAiB;YACnB,qDAAqD;YACrD,IAAI,SAAS,UAAU;gBACrB,MAAM,yHAAM,CAAC,YAAY,CAAC,MAAM,CAAC;oBAC/B,OAAO;wBAAE,IAAI,gBAAgB,EAAE;oBAAC;oBAChC,MAAM;wBACJ,UAAU,gBAAgB,QAAQ,GAAG,QAAQ,QAAQ;wBACrD,GAAI,QAAQ,QAAQ,IAAI;4BAAE,UAAU,QAAQ,QAAQ;wBAAC,CAAC;oBACxD;gBACF;YACF;QACF,OAAO;YACL,+BAA+B;YAC/B,MAAM,yHAAM,CAAC,YAAY,CAAC,MAAM,CAAC;gBAC/B,MAAM;oBACJ;oBACA,MAAM;oBACN,UAAU,SAAS,YAAY;oBAC/B,GAAI,SAAS,YAAY;wBAAE,UAAU,QAAQ,QAAQ;oBAAC,CAAC;gBACzD;YACF;QACF;IACF,EAAE,OAAO,OAAO;QACd,gEAAgE;QAChE,QAAQ,KAAK,CAAC,kCAAkC;IAClD;AACF;AAKO,eAAe,uBAAuB,MAAc,EAAE,QAAgB;IAC3E,MAAM,mBAAmB,QAAQ;QAC/B;QACA,UAAU;IACZ;AACF;AAKO,eAAe,qBACpB,MAAc,EACd,QAAgB,EAChB,SAAkB;IAElB,sDAAsD;IACtD,MAAM,WAAW,YAAY,KAAK,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,YAAY,OAAO;IAEvE,MAAM,mBAAmB,QAAQ;QAC/B;QACA;IACF;AACF;AAKO,eAAe,yBACpB,MAAc,EACd,SAAkB;IAElB,qEAAqE;IACrE,MAAM,WAAW,YAAY,KAAK,GAAG,CAAC,GAAG,KAAK,KAAK,CAAC,YAAY,OAAO;IAEvE,MAAM,mBAAmB,QAAQ;QAC/B;IACF;AACF;AAKO,eAAe,eAAe,MAAc;IACjD,MAAM,QAAQ,IAAI;IAClB,MAAM,cAAc,IAAI,KAAK;IAC7B,YAAY,OAAO,CAAC,MAAM,OAAO,KAAK,MAAM,MAAM,KAAK,IAAI,SAAS;IACpE,YAAY,QAAQ,CAAC,GAAG,GAAG,GAAG;IAE9B,MAAM,YAAY,IAAI,KAAK;IAC3B,UAAU,OAAO,CAAC,YAAY,OAAO,KAAK;IAC1C,UAAU,QAAQ,CAAC,IAAI,IAAI,IAAI;IAE/B,MAAM,WAAW,MAAM,yHAAM,CAAC,YAAY,CAAC,QAAQ,CAAC;QAClD,OAAO;YACL;YACA,MAAM;gBACJ,KAAK;gBACL,KAAK;YACP;QACF;QACA,SAAS;YACP,QAAQ;gBACN,QAAQ;oBACN,SAAS;gBACX;YACF;QACF;IACF;IAEA,MAAM,eAAe,SAAS,MAAM,CAAC,CAAC,KAAK,UAAY,MAAM,QAAQ,QAAQ,EAAE;IAC/E,MAAM,aAAa,IAAI,IACrB,SAAS,GAAG,CAAC,CAAC;QACZ,MAAM,IAAI,IAAI,KAAK,EAAE,IAAI;QACzB,EAAE,QAAQ,CAAC,GAAG,GAAG,GAAG;QACpB,OAAO,EAAE,OAAO;IAClB,IACA,IAAI;IAEN,OAAO;QACL,eAAe,SAAS,MAAM;QAC9B;QACA,YAAY,KAAK,KAAK,CAAC,AAAC,eAAe,KAAM,MAAM;QACnD,YAAY;QACZ;IACF;AACF"}},
    {"offset": {"line": 1174, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User/Documents/fDigit%20Technologies/NaijaPrepAI/app/api/quiz/attempt/route.ts"],"sourcesContent":["// üí• CRITICAL FIX: Forces Next.js to use the Node.js environment\r\nexport const runtime = 'nodejs';\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { auth } from '@/app/api/auth/[...nextauth]/route';\r\nimport { saveQuizAttempt } from '@/services/quizService';\r\nimport { awardXP, updateDailyStreak, checkAndAwardBadges, updateSubjectProgress, XP_VALUES } from '@/services/gamificationService';\r\nimport { recordQuizCompletion } from '@/services/studySessionService';\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const session = await auth();\r\n    if (!session?.user?.id) {\r\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n    }\r\n\r\n    const body = await request.json();\r\n    const { lessonId, answers, timeSpent, totalQuestions: providedTotalQuestions } = body;\r\n\r\n    if (!lessonId || !Array.isArray(answers)) {\r\n      return NextResponse.json(\r\n        { error: 'Missing required fields: lessonId and answers' },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    // Validate lesson exists and get total questions\r\n    const { prisma } = await import('@/lib/prisma');\r\n    const lesson = await prisma.lesson.findUnique({\r\n      where: { id: lessonId },\r\n      select: { \r\n        id: true,\r\n        practiceQuestions: true,\r\n        subject: true,\r\n      },\r\n    });\r\n\r\n    if (!lesson) {\r\n      return NextResponse.json(\r\n        { error: 'Lesson not found' },\r\n        { status: 404 }\r\n      );\r\n    }\r\n\r\n    // Get total questions from lesson or use provided value\r\n    let totalQuestions = providedTotalQuestions;\r\n    if (!totalQuestions) {\r\n      if (Array.isArray(lesson.practiceQuestions)) {\r\n        totalQuestions = lesson.practiceQuestions.length;\r\n      } else {\r\n        // Fallback to answered questions count\r\n        totalQuestions = answers.length;\r\n      }\r\n    }\r\n\r\n    // Calculate score based on answered questions\r\n    const answeredCount = answers.length;\r\n    const correctAnswers = answers.filter((a: any) => a.isCorrect).length;\r\n    // Score is percentage of correct answers out of total questions\r\n    const score = totalQuestions > 0 ? (correctAnswers / totalQuestions) * 100 : 0;\r\n\r\n    // Save quiz attempt\r\n    const attempt = await saveQuizAttempt({\r\n      userId: session.user.id,\r\n      lessonId,\r\n      totalQuestions,\r\n      correctAnswers,\r\n      score,\r\n      timeSpent: timeSpent || undefined,\r\n      answers,\r\n    });\r\n\r\n    // Award XP for completing quiz\r\n    try {\r\n      let xpEarned = XP_VALUES.COMPLETE_QUIZ;\r\n      if (score === 100) {\r\n        xpEarned += XP_VALUES.QUIZ_PERFECT_SCORE; // Bonus for perfect score\r\n      }\r\n      \r\n      await awardXP(session.user.id, xpEarned, `Completed quiz (${score.toFixed(0)}%)`);\r\n      await updateDailyStreak(session.user.id);\r\n      \r\n      // Record study session for weekly progress\r\n      await recordQuizCompletion(session.user.id, lessonId, timeSpent);\r\n      \r\n      // Update subject progress\r\n      await updateSubjectProgress(session.user.id, lesson.subject, {\r\n        quizzesPassed: 1,\r\n        xpEarned,\r\n      });\r\n      \r\n      // Check for badges\r\n      const user = await import('@/lib/prisma').then(m => m.prisma.user.findUnique({\r\n        where: { id: session.user.id },\r\n        include: {\r\n          quizAttempts: { select: { id: true, score: true } },\r\n        },\r\n      }));\r\n      \r\n      if (user) {\r\n        const perfectQuizzes = user.quizAttempts.filter(q => q.score === 100).length;\r\n        await checkAndAwardBadges(session.user.id, {\r\n          quizzesCompleted: user.quizAttempts.length,\r\n          perfectQuizzes,\r\n          subject: lesson.subject,\r\n        });\r\n      }\r\n    } catch (gamificationError) {\r\n      // Don't fail quiz save if gamification fails\r\n      console.error('Gamification error:', gamificationError);\r\n    }\r\n\r\n    return NextResponse.json({\r\n      success: true,\r\n      attempt: {\r\n        id: attempt.id,\r\n        score,\r\n        correctAnswers,\r\n        totalQuestions,\r\n        createdAt: attempt.createdAt,\r\n      },\r\n    });\r\n  } catch (error: any) {\r\n    console.error('Error saving quiz attempt:', error);\r\n    return NextResponse.json(\r\n      { \r\n        error: 'Failed to save quiz attempt',\r\n        details: error?.message || 'Unknown error',\r\n        stack: process.env.NODE_ENV === 'development' ? error?.stack : undefined\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}}]
}